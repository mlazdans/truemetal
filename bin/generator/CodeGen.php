<?php

use dqdp\Template;
use dqdp\TypeGenerator\AbstractTypeGenerator;
use dqdp\TypeGenerator\FieldInfoCollection;

class CodeGen
{
	public string $name;
	public string $output_folder;
	public ?string $namespace = null;
	public FieldInfoCollection $field_map;
	public bool $debug = false;
	public string|array|null $PK;
	public string $class_name;
	public array $other_namespaces = [];
	public bool $is_relation = false;
	public bool $is_proc = false;

	public string $autogenerated_msg = "# AUTOGENERATED - DO NOT MODIFY!";

	function __construct()
	{
	}

	private function get_namespace_str(): string
	{
		return $this->namespace ? "namespace $this->namespace;" : "";
	}

	function generate_type(): string
	{
		$t = new Template("templates/type.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);
		return $t->parse();
	}

	function generate_type_trait(): string
	{
		if($this->PK){
			if(is_array($this->PK)){
				$PkStr = (function(): string {
					foreach($this->PK as $f){
						$ret[] = "\$this->".$this->field_map[$f]->name;
					}
					return "[".join(", ", $ret??[])."]";
				})();
			} else {
				$PkStr = "\$this->".$this->field_map[$this->PK]->name;
			}
		} else {
			$PkStr = "";
		}

		$t = new Template("templates/type_trait.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);

		if($PkStr){
			$t->set_var('PkStr', $PkStr);
			$t->enable('BLOCK_upd_del');
		}

		// return $t->parse();

		// $toMap = $fromMap = [];
		// foreach($FieldMap as $db_field=>$FI){
		// 	$fromMap[] = "\t\t\t'$db_field'=>'$FI->name'";
		// 	if(!$FI->readonly){
		// 		$toMap[] = "\t\t\t'$FI->name'=>'$db_field'";
		// 	}
		// }

		// $fromMapStr = join(",\n", $fromMap);
		// $toMapStr = join(",\n", $toMap);
		if($this->other_namespaces){
			$b = $t->enable('OtherNamespaces');
			foreach($this->other_namespaces as $ns){
				$b->set_var('NS', $ns);
				$b->parse(TMPL_APPEND);
			}
		}

		$b = $t->enable('Fields');
		foreach($this->field_map as $f)
		{
			$b->set_var('FieldStr', sprintf("var %s%s $%s;",
				$f->nullflag ? "?" : "",
				$f->php_type,
				$f->name
			));
			$b->parse(TMPL_APPEND);

			$constrArgLines[] = "?$f->php_type \$$f->name = null";
			// $constrLines[] = "\t\tif(isset(\$$f->name))\$this->$f->name = \$$f->name;";
		}

		$t->set_var('ConstrArgsStr', join(", ", $constrArgLines??[]));
		// $t->set_var('constr_str', join("\n", $constrLines??[]));

		$b = $t->enable('ConstrInit');
		foreach($this->field_map as $f)
		{
			$b->set_var('ConstrStr', "if(isset(\$$f->name))\$this->$f->name = \$$f->name;");
			$b->parse(TMPL_APPEND);
		}

		// if($Constructors){
		// 	foreach($Constructors as $cstr){
		// 		$ret .= "\t\t$cstr\n";
		// 	}
		// }

		// $ret .= "\t}\n";

		// if($InitFunctions){
		// 	foreach($InitFunctions as $f){
		// 		$ret .= $f;
		// 	}
		// }

		// $ret .= <<<END

		// 	static function fromDBObject(array|object|null \$o): ?{$ClassName}Type {
		// 		if(is_null(\$o)){
		// 			return null;
		// 		}

		// 		\$map = [
		// $fromMapStr
		// 		];

		// 		\$params = [];
		// 		foreach(\$map as \$k=>\$v){
		// 			if(prop_exists(\$o, \$k)){
		// 				\$params[\$v] = get_prop(\$o, \$k);
		// 			}
		// 		}

		// 		return new static(\$params);
		// 	}

		// 	static function toDBObject(array|object|null \$o): \stdClass {
		// 		\$ret = new \stdClass;

		// 		\$map = [
		// $toMapStr
		// 		];

		// 		foreach(\$map as \$k=>\$v){
		// 			if(prop_isset(\$o, \$k)){
		// 				\$ret->{\$v} = get_prop(\$o, \$k);
		// 			}
		// 		}

		// 		return \$ret;
		// 	}
		// END;

		return $t->parse();
	}

	function generate_collection(): string
	{
		$t = new Template("templates/collection.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);

		return $t->parse();
	}

	function generate_entity_trait(AbstractTypeGenerator $DBA): string
	{
		$t = new Template("templates/entity_trait.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);

		if($this->PK){
			if(is_array($this->PK)){
				$pkArgType = "array";
				$PkStr = "['".join("','", $this->PK)."']";
				$pkFilterStr = (function(): string {
					foreach($this->PK as $f){
						$ret[] = "$f: \$ID['$f']";
					}
					return join(", ", $ret??[]);
				})();
			} else {
				$pkArgType = $this->field_map[$this->PK]->php_type;
				$PkStr = "'$this->PK'";
				$pkFilterStr = "$this->PK: \$ID";
			}
		} else {
			$PkStr = "null";
		}

		$t->set_var('PkStr', $PkStr);

		$GenStr = "null";
		if($genName = $DBA->get_sequence_name())
		{
			$GenStr = "'$genName'";
		}
		$t->set_var('GenStr', $GenStr);

		$procConstrStr = "";
		$procArgsStr = "null";
		$procNameStr = "null";
		if($this->is_proc){
			$procNameStr = "'$this->name'";
			$argMap = $DBA->get_proc_args();

			$procArgsStr = (function() use ($argMap) {
				foreach($argMap as $prop){
					$ret[] = "\$this->$prop->name";
				}
				return '['.join(",", $ret??[]).']';
			})();

			$procConstrStr = (function() use ($argMap) {
				foreach($argMap as $f){
					$ret[] = sprintf("readonly %s%s $%s",
						$f->nullflag,
						$f->php_type,
						$f->name
					);
				}
				return join(",", $ret??[]);
			})();

			$BaseEntity = "\dqdp\DBA\AbstractProcEntity";
		} else {
			$BaseEntity = "\dqdp\DBA\AbstractTableEntity";
		}

		$t->set_var('BaseEntity', $BaseEntity);

		if($this->is_proc)
		{
			$b = $t->enable('ProcConstr');
			$b->set_var('procConstrStr', $procConstrStr);
			$b->set_var('procNameStr', $procNameStr);
			$b->set_var('procArgsStr', $procArgsStr);
		} else {
			$b = $t->enable('RelConstr');
			$relNameStr = "null";
			if($this->is_relation){
				$relNameStr = "'$this->name'";
			}
			$b->set_var('relNameStr', $relNameStr);
		}

		if($this->PK) {
			$b = $t->enable('Get');
			$b->set_var('pkArgType', $pkArgType);
			$b->set_var('pkFilterStr', $pkFilterStr);
		}

		return $t->parse();
	}

	function generate_entity(): string
	{
		$t = new Template("templates/entity.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);

		return $t->parse();
	}

	function generate_filter(): string
	{
		$t = new Template("templates/filter.tpl.php");
		$t->set_var('AutoGeneratedMsg', $this->autogenerated_msg);
		$t->set_var('Namespace', $this->get_namespace_str());
		$t->set_var('ClassName', $this->class_name);

		foreach($this->field_map as $f)
		{
			$constrArgs[] = "public ?$f->php_type \$$f->name = null";
			$fieldArgs[] = $f->name;
		}

		$ConstrArgsStr = join(", ", $constrArgs ?? []);
		$FieldsStr = "'".join("', '", $fieldArgs ?? [])."'";

		$t->set_var('ConstrArgsStr', $ConstrArgsStr);
		if($FieldsStr) {
			$t->enable('Filters');
			$t->set_var('FieldsStr', $FieldsStr);
		}

		return $t->parse();
	}

	function save_type_trait()
	{
		# TODO: move to interface
		$directory = join_paths([$this->output_folder, $this->namespace, "Traits"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."TypeTrait.php";

		// $data = generateTypeTrait($ClassName, $NamespaceUse, $FieldMap, $Constructors, $PK, $InitFunctions);
		$data = $this->generate_type_trait();

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}

	function save_type()
	{
		$directory = join_paths([$this->output_folder, $this->namespace, "Types"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."Type.php";

		$data = $this->generate_type();

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}

	function save_collection()
	{
		$directory = join_paths([$this->output_folder, $this->namespace, "Types"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."Collection.php";

		$data = $this->generate_collection();

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}

	function save_entity_trait(AbstractTypeGenerator $DBA)
	{
		$directory = join_paths([$this->output_folder, $this->namespace, "Traits"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."EntityTrait.php";

		$data = $this->generate_entity_trait($DBA);

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}

	function save_entity()
	{
		$directory = join_paths([$this->output_folder, $this->namespace, "Entity"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."Entity.php";

		$data = $this->generate_entity();

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}

	function save_filter()
	{
		$directory = join_paths([$this->output_folder, $this->namespace, "Filters"]);

		if(!is_dir($directory)){
			mkdir(directory: $directory, recursive: true);
		}

		$fileName = $directory.DIRECTORY_SEPARATOR.$this->class_name."Filter.php";

		$data = $this->generate_filter();

		if($this->debug){
			print $data;
		}

		file_put_contents($fileName, $data);
	}
}
