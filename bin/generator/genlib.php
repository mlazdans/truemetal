<?php declare(strict_types = 1);

use dqdp\TypeGenerator\FieldInfoCollection;

// function process_fields(FieldInfoCollection $FieldMap)
// {
// 	$useDecimal = $useVarchar = $useChar = false;
// 	# TODO: figure something about strftime() deprecation
// 	// $ts_format = match($field_type){
// 	// 	'TIMESTAMP' => 'ibase.timestampformat',
// 	// 	'DATE' => 'ibase.dateformat',
// 	// 	'TIME' => 'ibase.timeformat',
// 	// };
// 	// if($default) {
// 	// 	if(stripos($default, "CURRENT_") === 0){
// 	// 		$constr_str .= "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = strftime(ini_get('$ts_format'), time());";
// 	// 	} else {
// 	// 		trigger_error("Unknown default: $default", E_USER_NOTICE);
// 	// 	}
// 	// }

// 	foreach($FieldMap as $FI)
// 	{
// 		$default = $FI->default;
// 		$prop_name = $FI->name;
// 		$constr_str = "";

// 		switch($FI->type)
// 		{
// 			case FieldType::int:
// 			{
// 				// Domain
// 				// if($field->FIELD_SOURCE == "BOOL"){
// 				// 	$propType = 'bool';
// 				// }

// 				if($default){
// 					$constr_str = "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = (int)$default;";
// 				}
// 			} break;
// 			case FieldType::decimal:
// 			{
// 				$useDecimal = true;
// 				$precision = $FI->precision;
// 				$scale = $FI->scale;

// 				$InitFunctions[] = <<<END

// 					static function init$prop_name(mixed \$v): string {
// 						return (string)(new Decimal(\$v, $precision, $scale));
// 					}

// 				END;
// 				if($default){
// 					$constr_str = "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = (string)$default;";
// 				}
// 			} break;
// 			case FieldType::float:
// 			{
// 				if($default){
// 					$constr_str = "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = (float)$default;";
// 				}
// 			} break;
// 			case FieldType::char:
// 			{
// 				$useChar = true;
// 				$len = $FI->len;

// 				$InitFunctions[] = <<<END

// 					static function init$prop_name(mixed \$v): string {
// 						return (string)(new Char(\$v, $len));
// 					}

// 				END;
// 				if($default){
// 					$constr_str = "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = $default;";
// 				}
// 			} break;
// 			case FieldType::varchar:
// 			{
// 				$useVarchar = true;
// 				$len = $FI->len;

// 				$InitFunctions[] = <<<END

// 					static function init$prop_name(mixed \$v): string {
// 						return (string)(new VarChar(\$v, $len));
// 					}

// 				END;
// 				if($default){
// 					$constr_str = "if(!prop_initialized(\$this, '$prop_name'))\$this->$prop_name = $default;";
// 				}
// 			} break;
// 		}

// 		if($constr_str){
// 			$Constructors[] = $constr_str;
// 		}
// 	}

// 	if($useVarchar)$Use[] = 'dqdp\DBA\Types\Varchar';
// 	if($useChar)$Use[] = 'dqdp\DBA\Types\Char';
// 	if($useDecimal)$Use[] = 'dqdp\DBA\Types\Decimal';

// 	return [$Use??[], $Constructors??[], $InitFunctions??[]];
// }

function generateDummyType(string $ClassName, FieldInfoCollection $FieldMap): string {
	global $AutoGeneratedMsg, $NamespaceStr;

	$ret =  <<<END
	<?php declare(strict_types = 1);

	$AutoGeneratedMsg
	# This Dummy type is useful for inner manipulations that do not require all the strictness
	# NULL properties has to be set outside constructor
	$NamespaceStr
	use dqdp\StricStdObject;

	class {$ClassName}Dummy extends StricStdObject {

	END;

	foreach($FieldMap as $f){
		if($f->readonly){
			continue;
		}

		# Dummy does not need defaults? Can be initialized using ::initFromDefaults()?
		$default = '';

		$ret .= "\tvar $f->nullflag$f->php_type \$$f->name$default;\n";
		$constrArgLines[] = "?$f->php_type \$$f->name = null";
		$constrLines[] = "\t\tif(isset(\$$f->name))\$this->$f->name = \$$f->name;";
	}

	$constrArgStr = join(", ", $constrArgLines??[]);
	$constrStr = join("\n", $constrLines??[]);

	$ret .= <<<END

		function __construct($constrArgStr) {
	$constrStr
		}

		function real(): {$ClassName}Type {
			return {$ClassName}Type::init_from(\$this);
		}

	END;

	$ret .= "}\n";

	return $ret;
}

