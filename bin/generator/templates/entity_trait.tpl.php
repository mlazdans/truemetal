<?php declare(strict_types = 1);

{AutoGeneratedMsg}
{Namespace}

use dqdp\DBA\AbstractFilter;

trait {ClassName}EntityTrait
{
	<!-- BEGIN ProcConstr disabled -->
	function __construct({procConstrStr}){
	}

	function get_proc_name(): string {
		return $procNameStr;
	}

	function get_proc_args(): ?array {
		return $procArgsStr;
	}
	<!-- END ProcConstr -->

	<!-- BEGIN RelConstr disabled -->
	function get_table_name(): string {
		return {relNameStr};
	}

	function get_pk(): string|array|null {
		return {PkStr};
	}

	function get_gen(): ?string {
		return {GenStr};
	}
	<!-- END RelConstr -->

	<!-- BEGIN Get disabled -->
	static function get({pkArgType} $ID, ?AbstractFilter $DF = null): ?{ClassName}Type {
		return (new static)->get_single((new {ClassName}Filter({pkFilterStr}))->merge($DF));
	}
	<!-- END Get -->

	function get_all(?AbstractFilter $filters = null): {ClassName}Collection {
		$col = new {ClassName}Collection;
		if($this->query($filters)){
			while($r = $this->fetch()){
				$col[] = $r;
			}
		}

		return $col;
	}

	function fetch(): ?{ClassName}Type {
		if($data = parent::fetch($this->Q)){
			return {ClassName}Type::initFrom($data);
		} else {
			return null;
		}
	}

	function save(array|object $DATA): mixed {
		return parent::save($DATA);
	}

	function insert(array|object $DATA): mixed {
		return parent::insert($DATA);
	}

	function update(int|string|array $ID, array|object $DATA): bool {
		return parent::update($ID, $DATA);
	}
}
